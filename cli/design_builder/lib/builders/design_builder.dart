import 'dart:io';

import 'package:design_builder/builders/component_builder.dart';
import 'package:design_builder/builders/constants_builder.dart';
import 'package:design_builder/builders/style_builder.dart';
import 'package:design_builder/builders/theme_builder.dart';
import 'package:recase/recase.dart';

class DesignBuilder {
  final String sourcePoint = 'src';
  final String targetPoint = 'out';
  final String packageName = 'example_design';
  final List<String> themes = ['light', 'dark'];

  String get inputDesignPath => "$sourcePoint/design/";
  String get outputDesignPath => '$targetPoint/design/';

  String get inputThemePath => "$sourcePoint/theme/";
  String get outputThemePath => '$targetPoint/theme/';

  String get inputConstantsPath => "$sourcePoint/constants/";
  String get outputConstantsPath => '$targetPoint/constants/';

  run() {
    final (:directories, :files) = getSourcePaths();

    directoryStructureProcess(directories);
    fileStructureProcess(files);
    ConstantsBuilder().copyConstants(source: inputConstantsPath, target: outputConstantsPath);
  }

  void fileStructureProcess(List<String> filePaths) {
    print("Building file structure...");

    final themeBuilder = ThemeBuilder(packageName, themes);
    final componentBuilder = ComponentBuilder(
      inputPath: inputDesignPath,
      outputPath: outputDesignPath,
    );
    final List<String> packages = [];

    for (final filePath in filePaths) {
      final pathList = filePath.split('/');
      final fileList = pathList.last.split('.');

      final fileType = fileList.last;
      if (fileType != 'dart') continue;

      final type = fileList[1];
      final name = fileList.first;
      final path = pathList.sublist(0, pathList.length - 1).join('/');

      switch (type) {
        case 'widget' || 'dart':
          componentBuilder.buildWidget(path, name);
          packages.add(filePath.replaceAll(sourcePoint, 'package:$packageName'));
          break;
        case 'style':
          componentBuilder.buildStyle(path, name);
          break;
        case 'theme':
          themeBuilder.addTheme(path, name);
      }
    }
    themeBuilder.buildThemeModes(inputPath: inputThemePath, outputPath: outputThemePath);
    exportPackageProcess(sourcePoint, targetPoint, packages: packages);
  }

  void exportPackageProcess(String inputPath, String outputPath, {required List<String> packages}) {
    print("Building exports...");

    StringBuffer sb = StringBuffer();
    for (final package in packages) {
      sb.writeln("export '$package';");
    }
    sb.writeln();

    final file = File('$inputPath/$packageName.dart');
    sb.write(file.readAsStringSync());
    File('$outputPath/$packageName.dart').writeAsStringSync(sb.toString());
  }

  void directoryStructureProcess(List<String> directories) {
    Map<String, List<String>> styles = {};
    final designPathLength = inputDesignPath.split('/').length;

    print("Building directory structure...");

    // Prepare directory structure
    for (var directory in directories) {
      final pathList = directory.split('/');
      final path = pathList.sublist(designPathLength - 1);
      final styleName = ReCase(path.last);

      final key = [...pathList.sublist(0, path.length + 1), ''].join('/');
      styles[key] = [...styles[key] ?? [], styleName.snakeCase];

      Directory(directory.replaceFirst(inputDesignPath, outputDesignPath)).createSync(recursive: true);
    }

    // Build directory styles
    print("Building directory styles...");
    for (final style in styles.entries) {
      final styleKeyList = style.key.split('/');
      final styleName = ReCase(styleKeyList[styleKeyList.length - 2]);
      final styleCode = StyleBuilder(
        packageName: packageName,
        className: styleName.originalText == 'design' ? "DesignTheme" : "${styleName.pascalCase}Style",
        fileName: styleName.snakeCase,
        filePath: style.key.replaceFirst('$sourcePoint/', ''),
        styles: style.value,
      ).build();

      final outputFile = File('${style.key.replaceFirst(inputDesignPath, outputDesignPath)}/${styleName.snakeCase}.style.dart');
      outputFile.writeAsStringSync(styleCode);
    }
  }

  ({List<String> directories, List<String> files}) getSourcePaths() {
    final result = _getSubdirectoriesAndFiles(inputDesignPath);
    final List<String> directories = [];
    final List<String> filePaths = [];
    for (final r in result) {
      if (r.isDirectory) {
        directories.add(r.path);
      } else {
        filePaths.add(r.path);
      }
    }
    return (directories: directories, files: filePaths);
  }

  /// This function was generated by AI
  List<({String path, bool isDirectory})> _getSubdirectoriesAndFiles(String path) {
    final directory = Directory(path);
    final subdirectories = directory.listSync().whereType<Directory>().toList();
    final files = directory.listSync().whereType<File>().toList();

    List<({String path, bool isDirectory})> result = [];

    for (final subdirectory in subdirectories) {
      result.add((path: subdirectory.path, isDirectory: true));
      result.addAll(_getSubdirectoriesAndFiles(subdirectory.path));
    }

    for (final file in files) {
      result.add((path: file.path, isDirectory: false));
    }

    return result;
  }
}
